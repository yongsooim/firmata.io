var ut = Object.defineProperty
var ft = (s, l, r) =>
  l in s
    ? ut(s, l, { enumerable: !0, configurable: !0, writable: !0, value: r })
    : (s[l] = r)
var A = (s, l, r) => (ft(s, typeof l != "symbol" ? l + "" : l, r), r)
var K = {},
  oe = {}
oe.byteLength = ht
oe.toByteArray = at
oe.fromByteArray = mt
var W = [],
  N = [],
  ct = typeof Uint8Array != "undefined" ? Uint8Array : Array,
  pe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
for (var q = 0, pt = pe.length; q < pt; ++q)
  (W[q] = pe[q]), (N[pe.charCodeAt(q)] = q)
N["-".charCodeAt(0)] = 62
N["_".charCodeAt(0)] = 63
function Me(s) {
  var l = s.length
  if (l % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4")
  var r = s.indexOf("=")
  r === -1 && (r = l)
  var o = r === l ? 0 : 4 - (r % 4)
  return [r, o]
}
function ht(s) {
  var l = Me(s),
    r = l[0],
    o = l[1]
  return ((r + o) * 3) / 4 - o
}
function lt(s, l, r) {
  return ((l + r) * 3) / 4 - r
}
function at(s) {
  var l,
    r = Me(s),
    o = r[0],
    c = r[1],
    h = new ct(lt(s, o, c)),
    E = 0,
    u = c > 0 ? o - 4 : o,
    m
  for (m = 0; m < u; m += 4)
    (l =
      (N[s.charCodeAt(m)] << 18) |
      (N[s.charCodeAt(m + 1)] << 12) |
      (N[s.charCodeAt(m + 2)] << 6) |
      N[s.charCodeAt(m + 3)]),
      (h[E++] = (l >> 16) & 255),
      (h[E++] = (l >> 8) & 255),
      (h[E++] = l & 255)
  return (
    c === 2 &&
      ((l = (N[s.charCodeAt(m)] << 2) | (N[s.charCodeAt(m + 1)] >> 4)),
      (h[E++] = l & 255)),
    c === 1 &&
      ((l =
        (N[s.charCodeAt(m)] << 10) |
        (N[s.charCodeAt(m + 1)] << 4) |
        (N[s.charCodeAt(m + 2)] >> 2)),
      (h[E++] = (l >> 8) & 255),
      (h[E++] = l & 255)),
    h
  )
}
function Et(s) {
  return W[(s >> 18) & 63] + W[(s >> 12) & 63] + W[(s >> 6) & 63] + W[s & 63]
}
function _t(s, l, r) {
  for (var o, c = [], h = l; h < r; h += 3)
    (o =
      ((s[h] << 16) & 16711680) + ((s[h + 1] << 8) & 65280) + (s[h + 2] & 255)),
      c.push(Et(o))
  return c.join("")
}
function mt(s) {
  for (
    var l, r = s.length, o = r % 3, c = [], h = 16383, E = 0, u = r - o;
    E < u;
    E += h
  )
    c.push(_t(s, E, E + h > u ? u : E + h))
  return (
    o === 1
      ? ((l = s[r - 1]), c.push(W[l >> 2] + W[(l << 4) & 63] + "=="))
      : o === 2 &&
        ((l = (s[r - 2] << 8) + s[r - 1]),
        c.push(W[l >> 10] + W[(l >> 4) & 63] + W[(l << 2) & 63] + "=")),
    c.join("")
  )
}
var me = {}
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ me.read =
  function (s, l, r, o, c) {
    var h,
      E,
      u = c * 8 - o - 1,
      m = (1 << u) - 1,
      I = m >> 1,
      w = -7,
      y = r ? c - 1 : 0,
      R = r ? -1 : 1,
      O = s[l + y]
    for (
      y += R, h = O & ((1 << -w) - 1), O >>= -w, w += u;
      w > 0;
      h = h * 256 + s[l + y], y += R, w -= 8
    );
    for (
      E = h & ((1 << -w) - 1), h >>= -w, w += o;
      w > 0;
      E = E * 256 + s[l + y], y += R, w -= 8
    );
    if (h === 0) h = 1 - I
    else {
      if (h === m) return E ? NaN : (O ? -1 : 1) * (1 / 0)
      ;(E = E + Math.pow(2, o)), (h = h - I)
    }
    return (O ? -1 : 1) * E * Math.pow(2, h - o)
  }
me.write = function (s, l, r, o, c, h) {
  var E,
    u,
    m,
    I = h * 8 - c - 1,
    w = (1 << I) - 1,
    y = w >> 1,
    R = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    O = o ? 0 : h - 1,
    C = o ? 1 : -1,
    b = l < 0 || (l === 0 && 1 / l < 0) ? 1 : 0
  for (
    l = Math.abs(l),
      isNaN(l) || l === 1 / 0
        ? ((u = isNaN(l) ? 1 : 0), (E = w))
        : ((E = Math.floor(Math.log(l) / Math.LN2)),
          l * (m = Math.pow(2, -E)) < 1 && (E--, (m *= 2)),
          E + y >= 1 ? (l += R / m) : (l += R * Math.pow(2, 1 - y)),
          l * m >= 2 && (E++, (m /= 2)),
          E + y >= w
            ? ((u = 0), (E = w))
            : E + y >= 1
            ? ((u = (l * m - 1) * Math.pow(2, c)), (E = E + y))
            : ((u = l * Math.pow(2, y - 1) * Math.pow(2, c)), (E = 0)));
    c >= 8;
    s[r + O] = u & 255, O += C, u /= 256, c -= 8
  );
  for (
    E = (E << c) | u, I += c;
    I > 0;
    s[r + O] = E & 255, O += C, E /= 256, I -= 8
  );
  s[r + O - C] |= b * 128
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ ;(function (s) {
  const l = oe,
    r = me,
    o =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null
  ;(s.Buffer = u), (s.SlowBuffer = ve), (s.INSPECT_MAX_BYTES = 50)
  const c = 2147483647
  ;(s.kMaxLength = c),
    (u.TYPED_ARRAY_SUPPORT = h()),
    !u.TYPED_ARRAY_SUPPORT &&
      typeof console != "undefined" &&
      typeof console.error == "function" &&
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      )
  function h() {
    try {
      const i = new Uint8Array(1),
        e = {
          foo: function () {
            return 42
          },
        }
      return (
        Object.setPrototypeOf(e, Uint8Array.prototype),
        Object.setPrototypeOf(i, e),
        i.foo() === 42
      )
    } catch {
      return !1
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (!!u.isBuffer(this)) return this.buffer
    },
  }),
    Object.defineProperty(u.prototype, "offset", {
      enumerable: !0,
      get: function () {
        if (!!u.isBuffer(this)) return this.byteOffset
      },
    })
  function E(i) {
    if (i > c)
      throw new RangeError('The value "' + i + '" is invalid for option "size"')
    const e = new Uint8Array(i)
    return Object.setPrototypeOf(e, u.prototype), e
  }
  function u(i, e, t) {
    if (typeof i == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      return y(i)
    }
    return m(i, e, t)
  }
  u.poolSize = 8192
  function m(i, e, t) {
    if (typeof i == "string") return R(i, e)
    if (ArrayBuffer.isView(i)) return C(i)
    if (i == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof i
      )
    if (
      L(i, ArrayBuffer) ||
      (i && L(i.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer != "undefined" &&
        (L(i, SharedArrayBuffer) || (i && L(i.buffer, SharedArrayBuffer))))
    )
      return b(i, e, t)
    if (typeof i == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      )
    const n = i.valueOf && i.valueOf()
    if (n != null && n !== i) return u.from(n, e, t)
    const f = $e(i)
    if (f) return f
    if (
      typeof Symbol != "undefined" &&
      Symbol.toPrimitive != null &&
      typeof i[Symbol.toPrimitive] == "function"
    )
      return u.from(i[Symbol.toPrimitive]("string"), e, t)
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof i
    )
  }
  ;(u.from = function (i, e, t) {
    return m(i, e, t)
  }),
    Object.setPrototypeOf(u.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(u, Uint8Array)
  function I(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number')
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"')
  }
  function w(i, e, t) {
    return (
      I(i),
      i <= 0
        ? E(i)
        : e !== void 0
        ? typeof t == "string"
          ? E(i).fill(e, t)
          : E(i).fill(e)
        : E(i)
    )
  }
  u.alloc = function (i, e, t) {
    return w(i, e, t)
  }
  function y(i) {
    return I(i), E(i < 0 ? 0 : se(i) | 0)
  }
  ;(u.allocUnsafe = function (i) {
    return y(i)
  }),
    (u.allocUnsafeSlow = function (i) {
      return y(i)
    })
  function R(i, e) {
    if (((typeof e != "string" || e === "") && (e = "utf8"), !u.isEncoding(e)))
      throw new TypeError("Unknown encoding: " + e)
    const t = ge(i, e) | 0
    let n = E(t)
    const f = n.write(i, e)
    return f !== t && (n = n.slice(0, f)), n
  }
  function O(i) {
    const e = i.length < 0 ? 0 : se(i.length) | 0,
      t = E(e)
    for (let n = 0; n < e; n += 1) t[n] = i[n] & 255
    return t
  }
  function C(i) {
    if (L(i, Uint8Array)) {
      const e = new Uint8Array(i)
      return b(e.buffer, e.byteOffset, e.byteLength)
    }
    return O(i)
  }
  function b(i, e, t) {
    if (e < 0 || i.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds')
    if (i.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds')
    let n
    return (
      e === void 0 && t === void 0
        ? (n = new Uint8Array(i))
        : t === void 0
        ? (n = new Uint8Array(i, e))
        : (n = new Uint8Array(i, e, t)),
      Object.setPrototypeOf(n, u.prototype),
      n
    )
  }
  function $e(i) {
    if (u.isBuffer(i)) {
      const e = se(i.length) | 0,
        t = E(e)
      return t.length === 0 || i.copy(t, 0, 0, e), t
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || ce(i.length) ? E(0) : O(i)
    if (i.type === "Buffer" && Array.isArray(i.data)) return O(i.data)
  }
  function se(i) {
    if (i >= c)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          c.toString(16) +
          " bytes"
      )
    return i | 0
  }
  function ve(i) {
    return +i != i && (i = 0), u.alloc(+i)
  }
  ;(u.isBuffer = function (e) {
    return e != null && e._isBuffer === !0 && e !== u.prototype
  }),
    (u.compare = function (e, t) {
      if (
        (L(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)),
        L(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)),
        !u.isBuffer(e) || !u.isBuffer(t))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      if (e === t) return 0
      let n = e.length,
        f = t.length
      for (let p = 0, a = Math.min(n, f); p < a; ++p)
        if (e[p] !== t[p]) {
          ;(n = e[p]), (f = t[p])
          break
        }
      return n < f ? -1 : f < n ? 1 : 0
    }),
    (u.isEncoding = function (e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0
        default:
          return !1
      }
    }),
    (u.concat = function (e, t) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers')
      if (e.length === 0) return u.alloc(0)
      let n
      if (t === void 0) for (t = 0, n = 0; n < e.length; ++n) t += e[n].length
      const f = u.allocUnsafe(t)
      let p = 0
      for (n = 0; n < e.length; ++n) {
        let a = e[n]
        if (L(a, Uint8Array))
          p + a.length > f.length
            ? (u.isBuffer(a) || (a = u.from(a)), a.copy(f, p))
            : Uint8Array.prototype.set.call(f, a, p)
        else if (u.isBuffer(a)) a.copy(f, p)
        else throw new TypeError('"list" argument must be an Array of Buffers')
        p += a.length
      }
      return f
    })
  function ge(i, e) {
    if (u.isBuffer(i)) return i.length
    if (ArrayBuffer.isView(i) || L(i, ArrayBuffer)) return i.byteLength
    if (typeof i != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof i
      )
    const t = i.length,
      n = arguments.length > 2 && arguments[2] === !0
    if (!n && t === 0) return 0
    let f = !1
    for (;;)
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t
        case "utf8":
        case "utf-8":
          return fe(i).length
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2
        case "hex":
          return t >>> 1
        case "base64":
          return Be(i).length
        default:
          if (f) return n ? -1 : fe(i).length
          ;(e = ("" + e).toLowerCase()), (f = !0)
      }
  }
  u.byteLength = ge
  function Ge(i, e, t) {
    let n = !1
    if (
      ((e === void 0 || e < 0) && (e = 0),
      e > this.length ||
        ((t === void 0 || t > this.length) && (t = this.length), t <= 0) ||
        ((t >>>= 0), (e >>>= 0), t <= e))
    )
      return ""
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return ze(this, e, t)
        case "utf8":
        case "utf-8":
          return ye(this, e, t)
        case "ascii":
          return Ke(this, e, t)
        case "latin1":
        case "binary":
          return Je(this, e, t)
        case "base64":
          return qe(this, e, t)
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ze(this, e, t)
        default:
          if (n) throw new TypeError("Unknown encoding: " + i)
          ;(i = (i + "").toLowerCase()), (n = !0)
      }
  }
  u.prototype._isBuffer = !0
  function Y(i, e, t) {
    const n = i[e]
    ;(i[e] = i[t]), (i[t] = n)
  }
  ;(u.prototype.swap16 = function () {
    const e = this.length
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits")
    for (let t = 0; t < e; t += 2) Y(this, t, t + 1)
    return this
  }),
    (u.prototype.swap32 = function () {
      const e = this.length
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits")
      for (let t = 0; t < e; t += 4) Y(this, t, t + 3), Y(this, t + 1, t + 2)
      return this
    }),
    (u.prototype.swap64 = function () {
      const e = this.length
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits")
      for (let t = 0; t < e; t += 8)
        Y(this, t, t + 7),
          Y(this, t + 1, t + 6),
          Y(this, t + 2, t + 5),
          Y(this, t + 3, t + 4)
      return this
    }),
    (u.prototype.toString = function () {
      const e = this.length
      return e === 0
        ? ""
        : arguments.length === 0
        ? ye(this, 0, e)
        : Ge.apply(this, arguments)
    }),
    (u.prototype.toLocaleString = u.prototype.toString),
    (u.prototype.equals = function (e) {
      if (!u.isBuffer(e)) throw new TypeError("Argument must be a Buffer")
      return this === e ? !0 : u.compare(this, e) === 0
    }),
    (u.prototype.inspect = function () {
      let e = ""
      const t = s.INSPECT_MAX_BYTES
      return (
        (e = this.toString("hex", 0, t)
          .replace(/(.{2})/g, "$1 ")
          .trim()),
        this.length > t && (e += " ... "),
        "<Buffer " + e + ">"
      )
    }),
    o && (u.prototype[o] = u.prototype.inspect),
    (u.prototype.compare = function (e, t, n, f, p) {
      if (
        (L(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)),
        !u.isBuffer(e))
      )
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof e
        )
      if (
        (t === void 0 && (t = 0),
        n === void 0 && (n = e ? e.length : 0),
        f === void 0 && (f = 0),
        p === void 0 && (p = this.length),
        t < 0 || n > e.length || f < 0 || p > this.length)
      )
        throw new RangeError("out of range index")
      if (f >= p && t >= n) return 0
      if (f >= p) return -1
      if (t >= n) return 1
      if (((t >>>= 0), (n >>>= 0), (f >>>= 0), (p >>>= 0), this === e)) return 0
      let a = p - f,
        d = n - t
      const T = Math.min(a, d),
        x = this.slice(f, p),
        B = e.slice(t, n)
      for (let P = 0; P < T; ++P)
        if (x[P] !== B[P]) {
          ;(a = x[P]), (d = B[P])
          break
        }
      return a < d ? -1 : d < a ? 1 : 0
    })
  function Se(i, e, t, n, f) {
    if (i.length === 0) return -1
    if (
      (typeof t == "string"
        ? ((n = t), (t = 0))
        : t > 2147483647
        ? (t = 2147483647)
        : t < -2147483648 && (t = -2147483648),
      (t = +t),
      ce(t) && (t = f ? 0 : i.length - 1),
      t < 0 && (t = i.length + t),
      t >= i.length)
    ) {
      if (f) return -1
      t = i.length - 1
    } else if (t < 0)
      if (f) t = 0
      else return -1
    if ((typeof e == "string" && (e = u.from(e, n)), u.isBuffer(e)))
      return e.length === 0 ? -1 : de(i, e, t, n, f)
    if (typeof e == "number")
      return (
        (e = e & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? f
            ? Uint8Array.prototype.indexOf.call(i, e, t)
            : Uint8Array.prototype.lastIndexOf.call(i, e, t)
          : de(i, [e], t, n, f)
      )
    throw new TypeError("val must be string, number or Buffer")
  }
  function de(i, e, t, n, f) {
    let p = 1,
      a = i.length,
      d = e.length
    if (
      n !== void 0 &&
      ((n = String(n).toLowerCase()),
      n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")
    ) {
      if (i.length < 2 || e.length < 2) return -1
      ;(p = 2), (a /= 2), (d /= 2), (t /= 2)
    }
    function T(B, P) {
      return p === 1 ? B[P] : B.readUInt16BE(P * p)
    }
    let x
    if (f) {
      let B = -1
      for (x = t; x < a; x++)
        if (T(i, x) === T(e, B === -1 ? 0 : x - B)) {
          if ((B === -1 && (B = x), x - B + 1 === d)) return B * p
        } else B !== -1 && (x -= x - B), (B = -1)
    } else
      for (t + d > a && (t = a - d), x = t; x >= 0; x--) {
        let B = !0
        for (let P = 0; P < d; P++)
          if (T(i, x + P) !== T(e, P)) {
            B = !1
            break
          }
        if (B) return x
      }
    return -1
  }
  ;(u.prototype.includes = function (e, t, n) {
    return this.indexOf(e, t, n) !== -1
  }),
    (u.prototype.indexOf = function (e, t, n) {
      return Se(this, e, t, n, !0)
    }),
    (u.prototype.lastIndexOf = function (e, t, n) {
      return Se(this, e, t, n, !1)
    })
  function Ye(i, e, t, n) {
    t = Number(t) || 0
    const f = i.length - t
    n ? ((n = Number(n)), n > f && (n = f)) : (n = f)
    const p = e.length
    n > p / 2 && (n = p / 2)
    let a
    for (a = 0; a < n; ++a) {
      const d = parseInt(e.substr(a * 2, 2), 16)
      if (ce(d)) return a
      i[t + a] = d
    }
    return a
  }
  function Ve(i, e, t, n) {
    return Z(fe(e, i.length - t), i, t, n)
  }
  function Xe(i, e, t, n) {
    return Z(rt(e), i, t, n)
  }
  function He(i, e, t, n) {
    return Z(Be(e), i, t, n)
  }
  function je(i, e, t, n) {
    return Z(nt(e, i.length - t), i, t, n)
  }
  ;(u.prototype.write = function (e, t, n, f) {
    if (t === void 0) (f = "utf8"), (n = this.length), (t = 0)
    else if (n === void 0 && typeof t == "string")
      (f = t), (n = this.length), (t = 0)
    else if (isFinite(t))
      (t = t >>> 0),
        isFinite(n)
          ? ((n = n >>> 0), f === void 0 && (f = "utf8"))
          : ((f = n), (n = void 0))
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      )
    const p = this.length - t
    if (
      ((n === void 0 || n > p) && (n = p),
      (e.length > 0 && (n < 0 || t < 0)) || t > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds")
    f || (f = "utf8")
    let a = !1
    for (;;)
      switch (f) {
        case "hex":
          return Ye(this, e, t, n)
        case "utf8":
        case "utf-8":
          return Ve(this, e, t, n)
        case "ascii":
        case "latin1":
        case "binary":
          return Xe(this, e, t, n)
        case "base64":
          return He(this, e, t, n)
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return je(this, e, t, n)
        default:
          if (a) throw new TypeError("Unknown encoding: " + f)
          ;(f = ("" + f).toLowerCase()), (a = !0)
      }
  }),
    (u.prototype.toJSON = function () {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      }
    })
  function qe(i, e, t) {
    return e === 0 && t === i.length
      ? l.fromByteArray(i)
      : l.fromByteArray(i.slice(e, t))
  }
  function ye(i, e, t) {
    t = Math.min(i.length, t)
    const n = []
    let f = e
    for (; f < t; ) {
      const p = i[f]
      let a = null,
        d = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1
      if (f + d <= t) {
        let T, x, B, P
        switch (d) {
          case 1:
            p < 128 && (a = p)
            break
          case 2:
            ;(T = i[f + 1]),
              (T & 192) === 128 &&
                ((P = ((p & 31) << 6) | (T & 63)), P > 127 && (a = P))
            break
          case 3:
            ;(T = i[f + 1]),
              (x = i[f + 2]),
              (T & 192) === 128 &&
                (x & 192) === 128 &&
                ((P = ((p & 15) << 12) | ((T & 63) << 6) | (x & 63)),
                P > 2047 && (P < 55296 || P > 57343) && (a = P))
            break
          case 4:
            ;(T = i[f + 1]),
              (x = i[f + 2]),
              (B = i[f + 3]),
              (T & 192) === 128 &&
                (x & 192) === 128 &&
                (B & 192) === 128 &&
                ((P =
                  ((p & 15) << 18) |
                  ((T & 63) << 12) |
                  ((x & 63) << 6) |
                  (B & 63)),
                P > 65535 && P < 1114112 && (a = P))
        }
      }
      a === null
        ? ((a = 65533), (d = 1))
        : a > 65535 &&
          ((a -= 65536),
          n.push(((a >>> 10) & 1023) | 55296),
          (a = 56320 | (a & 1023))),
        n.push(a),
        (f += d)
    }
    return Qe(n)
  }
  const Ie = 4096
  function Qe(i) {
    const e = i.length
    if (e <= Ie) return String.fromCharCode.apply(String, i)
    let t = "",
      n = 0
    for (; n < e; )
      t += String.fromCharCode.apply(String, i.slice(n, (n += Ie)))
    return t
  }
  function Ke(i, e, t) {
    let n = ""
    t = Math.min(i.length, t)
    for (let f = e; f < t; ++f) n += String.fromCharCode(i[f] & 127)
    return n
  }
  function Je(i, e, t) {
    let n = ""
    t = Math.min(i.length, t)
    for (let f = e; f < t; ++f) n += String.fromCharCode(i[f])
    return n
  }
  function ze(i, e, t) {
    const n = i.length
    ;(!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n)
    let f = ""
    for (let p = e; p < t; ++p) f += ot[i[p]]
    return f
  }
  function Ze(i, e, t) {
    const n = i.slice(e, t)
    let f = ""
    for (let p = 0; p < n.length - 1; p += 2)
      f += String.fromCharCode(n[p] + n[p + 1] * 256)
    return f
  }
  u.prototype.slice = function (e, t) {
    const n = this.length
    ;(e = ~~e),
      (t = t === void 0 ? n : ~~t),
      e < 0 ? ((e += n), e < 0 && (e = 0)) : e > n && (e = n),
      t < 0 ? ((t += n), t < 0 && (t = 0)) : t > n && (t = n),
      t < e && (t = e)
    const f = this.subarray(e, t)
    return Object.setPrototypeOf(f, u.prototype), f
  }
  function U(i, e, t) {
    if (i % 1 !== 0 || i < 0) throw new RangeError("offset is not uint")
    if (i + e > t) throw new RangeError("Trying to access beyond buffer length")
  }
  ;(u.prototype.readUintLE = u.prototype.readUIntLE =
    function (e, t, n) {
      ;(e = e >>> 0), (t = t >>> 0), n || U(e, t, this.length)
      let f = this[e],
        p = 1,
        a = 0
      for (; ++a < t && (p *= 256); ) f += this[e + a] * p
      return f
    }),
    (u.prototype.readUintBE = u.prototype.readUIntBE =
      function (e, t, n) {
        ;(e = e >>> 0), (t = t >>> 0), n || U(e, t, this.length)
        let f = this[e + --t],
          p = 1
        for (; t > 0 && (p *= 256); ) f += this[e + --t] * p
        return f
      }),
    (u.prototype.readUint8 = u.prototype.readUInt8 =
      function (e, t) {
        return (e = e >>> 0), t || U(e, 1, this.length), this[e]
      }),
    (u.prototype.readUint16LE = u.prototype.readUInt16LE =
      function (e, t) {
        return (
          (e = e >>> 0), t || U(e, 2, this.length), this[e] | (this[e + 1] << 8)
        )
      }),
    (u.prototype.readUint16BE = u.prototype.readUInt16BE =
      function (e, t) {
        return (
          (e = e >>> 0), t || U(e, 2, this.length), (this[e] << 8) | this[e + 1]
        )
      }),
    (u.prototype.readUint32LE = u.prototype.readUInt32LE =
      function (e, t) {
        return (
          (e = e >>> 0),
          t || U(e, 4, this.length),
          (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
            this[e + 3] * 16777216
        )
      }),
    (u.prototype.readUint32BE = u.prototype.readUInt32BE =
      function (e, t) {
        return (
          (e = e >>> 0),
          t || U(e, 4, this.length),
          this[e] * 16777216 +
            ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
        )
      }),
    (u.prototype.readBigUInt64LE = $(function (e) {
      ;(e = e >>> 0), j(e, "offset")
      const t = this[e],
        n = this[e + 7]
      ;(t === void 0 || n === void 0) && Q(e, this.length - 8)
      const f =
          t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
        p = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24
      return BigInt(f) + (BigInt(p) << BigInt(32))
    })),
    (u.prototype.readBigUInt64BE = $(function (e) {
      ;(e = e >>> 0), j(e, "offset")
      const t = this[e],
        n = this[e + 7]
      ;(t === void 0 || n === void 0) && Q(e, this.length - 8)
      const f =
          t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
        p = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n
      return (BigInt(f) << BigInt(32)) + BigInt(p)
    })),
    (u.prototype.readIntLE = function (e, t, n) {
      ;(e = e >>> 0), (t = t >>> 0), n || U(e, t, this.length)
      let f = this[e],
        p = 1,
        a = 0
      for (; ++a < t && (p *= 256); ) f += this[e + a] * p
      return (p *= 128), f >= p && (f -= Math.pow(2, 8 * t)), f
    }),
    (u.prototype.readIntBE = function (e, t, n) {
      ;(e = e >>> 0), (t = t >>> 0), n || U(e, t, this.length)
      let f = t,
        p = 1,
        a = this[e + --f]
      for (; f > 0 && (p *= 256); ) a += this[e + --f] * p
      return (p *= 128), a >= p && (a -= Math.pow(2, 8 * t)), a
    }),
    (u.prototype.readInt8 = function (e, t) {
      return (
        (e = e >>> 0),
        t || U(e, 1, this.length),
        this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
      )
    }),
    (u.prototype.readInt16LE = function (e, t) {
      ;(e = e >>> 0), t || U(e, 2, this.length)
      const n = this[e] | (this[e + 1] << 8)
      return n & 32768 ? n | 4294901760 : n
    }),
    (u.prototype.readInt16BE = function (e, t) {
      ;(e = e >>> 0), t || U(e, 2, this.length)
      const n = this[e + 1] | (this[e] << 8)
      return n & 32768 ? n | 4294901760 : n
    }),
    (u.prototype.readInt32LE = function (e, t) {
      return (
        (e = e >>> 0),
        t || U(e, 4, this.length),
        this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24)
      )
    }),
    (u.prototype.readInt32BE = function (e, t) {
      return (
        (e = e >>> 0),
        t || U(e, 4, this.length),
        (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]
      )
    }),
    (u.prototype.readBigInt64LE = $(function (e) {
      ;(e = e >>> 0), j(e, "offset")
      const t = this[e],
        n = this[e + 7]
      ;(t === void 0 || n === void 0) && Q(e, this.length - 8)
      const f =
        this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24)
      return (
        (BigInt(f) << BigInt(32)) +
        BigInt(
          t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24
        )
      )
    })),
    (u.prototype.readBigInt64BE = $(function (e) {
      ;(e = e >>> 0), j(e, "offset")
      const t = this[e],
        n = this[e + 7]
      ;(t === void 0 || n === void 0) && Q(e, this.length - 8)
      const f = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e]
      return (
        (BigInt(f) << BigInt(32)) +
        BigInt(
          this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n
        )
      )
    })),
    (u.prototype.readFloatLE = function (e, t) {
      return (
        (e = e >>> 0), t || U(e, 4, this.length), r.read(this, e, !0, 23, 4)
      )
    }),
    (u.prototype.readFloatBE = function (e, t) {
      return (
        (e = e >>> 0), t || U(e, 4, this.length), r.read(this, e, !1, 23, 4)
      )
    }),
    (u.prototype.readDoubleLE = function (e, t) {
      return (
        (e = e >>> 0), t || U(e, 8, this.length), r.read(this, e, !0, 52, 8)
      )
    }),
    (u.prototype.readDoubleBE = function (e, t) {
      return (
        (e = e >>> 0), t || U(e, 8, this.length), r.read(this, e, !1, 52, 8)
      )
    })
  function F(i, e, t, n, f, p) {
    if (!u.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance')
    if (e > f || e < p)
      throw new RangeError('"value" argument is out of bounds')
    if (t + n > i.length) throw new RangeError("Index out of range")
  }
  ;(u.prototype.writeUintLE = u.prototype.writeUIntLE =
    function (e, t, n, f) {
      if (((e = +e), (t = t >>> 0), (n = n >>> 0), !f)) {
        const d = Math.pow(2, 8 * n) - 1
        F(this, e, t, n, d, 0)
      }
      let p = 1,
        a = 0
      for (this[t] = e & 255; ++a < n && (p *= 256); )
        this[t + a] = (e / p) & 255
      return t + n
    }),
    (u.prototype.writeUintBE = u.prototype.writeUIntBE =
      function (e, t, n, f) {
        if (((e = +e), (t = t >>> 0), (n = n >>> 0), !f)) {
          const d = Math.pow(2, 8 * n) - 1
          F(this, e, t, n, d, 0)
        }
        let p = n - 1,
          a = 1
        for (this[t + p] = e & 255; --p >= 0 && (a *= 256); )
          this[t + p] = (e / a) & 255
        return t + n
      }),
    (u.prototype.writeUint8 = u.prototype.writeUInt8 =
      function (e, t, n) {
        return (
          (e = +e),
          (t = t >>> 0),
          n || F(this, e, t, 1, 255, 0),
          (this[t] = e & 255),
          t + 1
        )
      }),
    (u.prototype.writeUint16LE = u.prototype.writeUInt16LE =
      function (e, t, n) {
        return (
          (e = +e),
          (t = t >>> 0),
          n || F(this, e, t, 2, 65535, 0),
          (this[t] = e & 255),
          (this[t + 1] = e >>> 8),
          t + 2
        )
      }),
    (u.prototype.writeUint16BE = u.prototype.writeUInt16BE =
      function (e, t, n) {
        return (
          (e = +e),
          (t = t >>> 0),
          n || F(this, e, t, 2, 65535, 0),
          (this[t] = e >>> 8),
          (this[t + 1] = e & 255),
          t + 2
        )
      }),
    (u.prototype.writeUint32LE = u.prototype.writeUInt32LE =
      function (e, t, n) {
        return (
          (e = +e),
          (t = t >>> 0),
          n || F(this, e, t, 4, 4294967295, 0),
          (this[t + 3] = e >>> 24),
          (this[t + 2] = e >>> 16),
          (this[t + 1] = e >>> 8),
          (this[t] = e & 255),
          t + 4
        )
      }),
    (u.prototype.writeUint32BE = u.prototype.writeUInt32BE =
      function (e, t, n) {
        return (
          (e = +e),
          (t = t >>> 0),
          n || F(this, e, t, 4, 4294967295, 0),
          (this[t] = e >>> 24),
          (this[t + 1] = e >>> 16),
          (this[t + 2] = e >>> 8),
          (this[t + 3] = e & 255),
          t + 4
        )
      })
  function Ae(i, e, t, n, f) {
    Te(e, n, f, i, t, 7)
    let p = Number(e & BigInt(4294967295))
    ;(i[t++] = p),
      (p = p >> 8),
      (i[t++] = p),
      (p = p >> 8),
      (i[t++] = p),
      (p = p >> 8),
      (i[t++] = p)
    let a = Number((e >> BigInt(32)) & BigInt(4294967295))
    return (
      (i[t++] = a),
      (a = a >> 8),
      (i[t++] = a),
      (a = a >> 8),
      (i[t++] = a),
      (a = a >> 8),
      (i[t++] = a),
      t
    )
  }
  function we(i, e, t, n, f) {
    Te(e, n, f, i, t, 7)
    let p = Number(e & BigInt(4294967295))
    ;(i[t + 7] = p),
      (p = p >> 8),
      (i[t + 6] = p),
      (p = p >> 8),
      (i[t + 5] = p),
      (p = p >> 8),
      (i[t + 4] = p)
    let a = Number((e >> BigInt(32)) & BigInt(4294967295))
    return (
      (i[t + 3] = a),
      (a = a >> 8),
      (i[t + 2] = a),
      (a = a >> 8),
      (i[t + 1] = a),
      (a = a >> 8),
      (i[t] = a),
      t + 8
    )
  }
  ;(u.prototype.writeBigUInt64LE = $(function (e, t = 0) {
    return Ae(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
  })),
    (u.prototype.writeBigUInt64BE = $(function (e, t = 0) {
      return we(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
    })),
    (u.prototype.writeIntLE = function (e, t, n, f) {
      if (((e = +e), (t = t >>> 0), !f)) {
        const T = Math.pow(2, 8 * n - 1)
        F(this, e, t, n, T - 1, -T)
      }
      let p = 0,
        a = 1,
        d = 0
      for (this[t] = e & 255; ++p < n && (a *= 256); )
        e < 0 && d === 0 && this[t + p - 1] !== 0 && (d = 1),
          (this[t + p] = (((e / a) >> 0) - d) & 255)
      return t + n
    }),
    (u.prototype.writeIntBE = function (e, t, n, f) {
      if (((e = +e), (t = t >>> 0), !f)) {
        const T = Math.pow(2, 8 * n - 1)
        F(this, e, t, n, T - 1, -T)
      }
      let p = n - 1,
        a = 1,
        d = 0
      for (this[t + p] = e & 255; --p >= 0 && (a *= 256); )
        e < 0 && d === 0 && this[t + p + 1] !== 0 && (d = 1),
          (this[t + p] = (((e / a) >> 0) - d) & 255)
      return t + n
    }),
    (u.prototype.writeInt8 = function (e, t, n) {
      return (
        (e = +e),
        (t = t >>> 0),
        n || F(this, e, t, 1, 127, -128),
        e < 0 && (e = 255 + e + 1),
        (this[t] = e & 255),
        t + 1
      )
    }),
    (u.prototype.writeInt16LE = function (e, t, n) {
      return (
        (e = +e),
        (t = t >>> 0),
        n || F(this, e, t, 2, 32767, -32768),
        (this[t] = e & 255),
        (this[t + 1] = e >>> 8),
        t + 2
      )
    }),
    (u.prototype.writeInt16BE = function (e, t, n) {
      return (
        (e = +e),
        (t = t >>> 0),
        n || F(this, e, t, 2, 32767, -32768),
        (this[t] = e >>> 8),
        (this[t + 1] = e & 255),
        t + 2
      )
    }),
    (u.prototype.writeInt32LE = function (e, t, n) {
      return (
        (e = +e),
        (t = t >>> 0),
        n || F(this, e, t, 4, 2147483647, -2147483648),
        (this[t] = e & 255),
        (this[t + 1] = e >>> 8),
        (this[t + 2] = e >>> 16),
        (this[t + 3] = e >>> 24),
        t + 4
      )
    }),
    (u.prototype.writeInt32BE = function (e, t, n) {
      return (
        (e = +e),
        (t = t >>> 0),
        n || F(this, e, t, 4, 2147483647, -2147483648),
        e < 0 && (e = 4294967295 + e + 1),
        (this[t] = e >>> 24),
        (this[t + 1] = e >>> 16),
        (this[t + 2] = e >>> 8),
        (this[t + 3] = e & 255),
        t + 4
      )
    }),
    (u.prototype.writeBigInt64LE = $(function (e, t = 0) {
      return Ae(
        this,
        e,
        t,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff")
      )
    })),
    (u.prototype.writeBigInt64BE = $(function (e, t = 0) {
      return we(
        this,
        e,
        t,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff")
      )
    }))
  function Re(i, e, t, n, f, p) {
    if (t + n > i.length) throw new RangeError("Index out of range")
    if (t < 0) throw new RangeError("Index out of range")
  }
  function Pe(i, e, t, n, f) {
    return (
      (e = +e),
      (t = t >>> 0),
      f || Re(i, e, t, 4),
      r.write(i, e, t, n, 23, 4),
      t + 4
    )
  }
  ;(u.prototype.writeFloatLE = function (e, t, n) {
    return Pe(this, e, t, !0, n)
  }),
    (u.prototype.writeFloatBE = function (e, t, n) {
      return Pe(this, e, t, !1, n)
    })
  function Ce(i, e, t, n, f) {
    return (
      (e = +e),
      (t = t >>> 0),
      f || Re(i, e, t, 8),
      r.write(i, e, t, n, 52, 8),
      t + 8
    )
  }
  ;(u.prototype.writeDoubleLE = function (e, t, n) {
    return Ce(this, e, t, !0, n)
  }),
    (u.prototype.writeDoubleBE = function (e, t, n) {
      return Ce(this, e, t, !1, n)
    }),
    (u.prototype.copy = function (e, t, n, f) {
      if (!u.isBuffer(e)) throw new TypeError("argument should be a Buffer")
      if (
        (n || (n = 0),
        !f && f !== 0 && (f = this.length),
        t >= e.length && (t = e.length),
        t || (t = 0),
        f > 0 && f < n && (f = n),
        f === n || e.length === 0 || this.length === 0)
      )
        return 0
      if (t < 0) throw new RangeError("targetStart out of bounds")
      if (n < 0 || n >= this.length) throw new RangeError("Index out of range")
      if (f < 0) throw new RangeError("sourceEnd out of bounds")
      f > this.length && (f = this.length),
        e.length - t < f - n && (f = e.length - t + n)
      const p = f - n
      return (
        this === e && typeof Uint8Array.prototype.copyWithin == "function"
          ? this.copyWithin(t, n, f)
          : Uint8Array.prototype.set.call(e, this.subarray(n, f), t),
        p
      )
    }),
    (u.prototype.fill = function (e, t, n, f) {
      if (typeof e == "string") {
        if (
          (typeof t == "string"
            ? ((f = t), (t = 0), (n = this.length))
            : typeof n == "string" && ((f = n), (n = this.length)),
          f !== void 0 && typeof f != "string")
        )
          throw new TypeError("encoding must be a string")
        if (typeof f == "string" && !u.isEncoding(f))
          throw new TypeError("Unknown encoding: " + f)
        if (e.length === 1) {
          const a = e.charCodeAt(0)
          ;((f === "utf8" && a < 128) || f === "latin1") && (e = a)
        }
      } else
        typeof e == "number"
          ? (e = e & 255)
          : typeof e == "boolean" && (e = Number(e))
      if (t < 0 || this.length < t || this.length < n)
        throw new RangeError("Out of range index")
      if (n <= t) return this
      ;(t = t >>> 0), (n = n === void 0 ? this.length : n >>> 0), e || (e = 0)
      let p
      if (typeof e == "number") for (p = t; p < n; ++p) this[p] = e
      else {
        const a = u.isBuffer(e) ? e : u.from(e, f),
          d = a.length
        if (d === 0)
          throw new TypeError(
            'The value "' + e + '" is invalid for argument "value"'
          )
        for (p = 0; p < n - t; ++p) this[p + t] = a[p % d]
      }
      return this
    })
  const H = {}
  function ue(i, e, t) {
    H[i] = class extends t {
      constructor() {
        super(),
          Object.defineProperty(this, "message", {
            value: e.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${i}]`),
          this.stack,
          delete this.name
      }
      get code() {
        return i
      }
      set code(f) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0,
        })
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`
      }
    }
  }
  ue(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (i) {
      return i
        ? `${i} is outside of buffer bounds`
        : "Attempt to access memory outside buffer bounds"
    },
    RangeError
  ),
    ue(
      "ERR_INVALID_ARG_TYPE",
      function (i, e) {
        return `The "${i}" argument must be of type number. Received type ${typeof e}`
      },
      TypeError
    ),
    ue(
      "ERR_OUT_OF_RANGE",
      function (i, e, t) {
        let n = `The value of "${i}" is out of range.`,
          f = t
        return (
          Number.isInteger(t) && Math.abs(t) > 2 ** 32
            ? (f = xe(String(t)))
            : typeof t == "bigint" &&
              ((f = String(t)),
              (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) &&
                (f = xe(f)),
              (f += "n")),
          (n += ` It must be ${e}. Received ${f}`),
          n
        )
      },
      RangeError
    )
  function xe(i) {
    let e = "",
      t = i.length
    const n = i[0] === "-" ? 1 : 0
    for (; t >= n + 4; t -= 3) e = `_${i.slice(t - 3, t)}${e}`
    return `${i.slice(0, t)}${e}`
  }
  function et(i, e, t) {
    j(e, "offset"),
      (i[e] === void 0 || i[e + t] === void 0) && Q(e, i.length - (t + 1))
  }
  function Te(i, e, t, n, f, p) {
    if (i > t || i < e) {
      const a = typeof e == "bigint" ? "n" : ""
      let d
      throw (
        (p > 3
          ? e === 0 || e === BigInt(0)
            ? (d = `>= 0${a} and < 2${a} ** ${(p + 1) * 8}${a}`)
            : (d = `>= -(2${a} ** ${(p + 1) * 8 - 1}${a}) and < 2 ** ${
                (p + 1) * 8 - 1
              }${a}`)
          : (d = `>= ${e}${a} and <= ${t}${a}`),
        new H.ERR_OUT_OF_RANGE("value", d, i))
      )
    }
    et(n, f, p)
  }
  function j(i, e) {
    if (typeof i != "number") throw new H.ERR_INVALID_ARG_TYPE(e, "number", i)
  }
  function Q(i, e, t) {
    throw Math.floor(i) !== i
      ? (j(i, t), new H.ERR_OUT_OF_RANGE(t || "offset", "an integer", i))
      : e < 0
      ? new H.ERR_BUFFER_OUT_OF_BOUNDS()
      : new H.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${e}`, i)
  }
  const tt = /[^+/0-9A-Za-z-_]/g
  function it(i) {
    if (((i = i.split("=")[0]), (i = i.trim().replace(tt, "")), i.length < 2))
      return ""
    for (; i.length % 4 !== 0; ) i = i + "="
    return i
  }
  function fe(i, e) {
    e = e || 1 / 0
    let t
    const n = i.length
    let f = null
    const p = []
    for (let a = 0; a < n; ++a) {
      if (((t = i.charCodeAt(a)), t > 55295 && t < 57344)) {
        if (!f) {
          if (t > 56319) {
            ;(e -= 3) > -1 && p.push(239, 191, 189)
            continue
          } else if (a + 1 === n) {
            ;(e -= 3) > -1 && p.push(239, 191, 189)
            continue
          }
          f = t
          continue
        }
        if (t < 56320) {
          ;(e -= 3) > -1 && p.push(239, 191, 189), (f = t)
          continue
        }
        t = (((f - 55296) << 10) | (t - 56320)) + 65536
      } else f && (e -= 3) > -1 && p.push(239, 191, 189)
      if (((f = null), t < 128)) {
        if ((e -= 1) < 0) break
        p.push(t)
      } else if (t < 2048) {
        if ((e -= 2) < 0) break
        p.push((t >> 6) | 192, (t & 63) | 128)
      } else if (t < 65536) {
        if ((e -= 3) < 0) break
        p.push((t >> 12) | 224, ((t >> 6) & 63) | 128, (t & 63) | 128)
      } else if (t < 1114112) {
        if ((e -= 4) < 0) break
        p.push(
          (t >> 18) | 240,
          ((t >> 12) & 63) | 128,
          ((t >> 6) & 63) | 128,
          (t & 63) | 128
        )
      } else throw new Error("Invalid code point")
    }
    return p
  }
  function rt(i) {
    const e = []
    for (let t = 0; t < i.length; ++t) e.push(i.charCodeAt(t) & 255)
    return e
  }
  function nt(i, e) {
    let t, n, f
    const p = []
    for (let a = 0; a < i.length && !((e -= 2) < 0); ++a)
      (t = i.charCodeAt(a)), (n = t >> 8), (f = t % 256), p.push(f), p.push(n)
    return p
  }
  function Be(i) {
    return l.toByteArray(it(i))
  }
  function Z(i, e, t, n) {
    let f
    for (f = 0; f < n && !(f + t >= e.length || f >= i.length); ++f)
      e[f + t] = i[f]
    return f
  }
  function L(i, e) {
    return (
      i instanceof e ||
      (i != null &&
        i.constructor != null &&
        i.constructor.name != null &&
        i.constructor.name === e.name)
    )
  }
  function ce(i) {
    return i !== i
  }
  const ot = (function () {
    const i = "0123456789abcdef",
      e = new Array(256)
    for (let t = 0; t < 16; ++t) {
      const n = t * 16
      for (let f = 0; f < 16; ++f) e[n + f] = i[t] + i[f]
    }
    return e
  })()
  function $(i) {
    return typeof BigInt == "undefined" ? st : i
  }
  function st() {
    throw new Error("BigInt not supported")
  }
})(K)
const gt = require("events"),
  Le = require("./encoder7bit"),
  Oe = require("./onewireutils"),
  J = new Map(),
  St = 105,
  dt = 106,
  he = 224,
  yt = 107,
  It = 108,
  le = 144,
  g = 247,
  At = 111,
  wt = 120,
  Rt = 119,
  v = 118,
  Pt = 24,
  Ct = 65,
  ee = 115,
  xt = 16,
  Tt = 67,
  Ue = 8,
  Bt = 1,
  Ot = 69,
  Ut = 68,
  Ft = 66,
  Dt = 64,
  Nt = 60,
  Fe = 32,
  Mt = 244,
  Lt = 109,
  Wt = 110,
  ae = 117,
  We = 121,
  kt = 192,
  bt = 208,
  te = 249,
  $t = 122,
  vt = 112,
  G = 96,
  Gt = 16,
  Yt = 32,
  De = 48,
  Vt = 64,
  Xt = 80,
  Ht = 96,
  jt = 112,
  _ = 240,
  Ee = 114,
  D = 98,
  ke = 113,
  qt = 255,
  Qt = 128,
  ie = Symbol("sendOneWireSearch"),
  X = Symbol("sendOneWireRequest"),
  re = {
    [te](s) {
      ;(s.version.major = s.buffer[1]),
        (s.version.minor = s.buffer[2]),
        s.emit("reportversion")
    },
    [he](s) {
      const l = s.buffer[0] & 15,
        r = s.buffer[1] | (s.buffer[2] << 7)
      s.pins[s.analogPins[l]] && (s.pins[s.analogPins[l]].value = r),
        s.emit(`analog-read-${l}`, r),
        s.emit("analog-read", { pin: l, value: r })
    },
    [le](s) {
      const l = s.buffer[0] & 15,
        r = s.buffer[1] | (s.buffer[2] << 7)
      for (let o = 0; o < 8; o++) {
        const c = 8 * l + o,
          h = s.pins[c],
          E = 1 << o
        if (h && (h.mode === s.MODES.INPUT || h.mode === s.MODES.PULLUP)) {
          ;(h.value = (r >> (o & 7)) & 1),
            h.value ? (s.ports[l] |= E) : (s.ports[l] &= ~E)
          let { value: u } = h
          s.emit(`digital-read-${c}`, u),
            s.emit("digital-read", { pin: c, value: u })
        }
      }
    },
  },
  z = {
    [We](s) {
      const l = s.buffer.length - 2,
        r = K.Buffer.alloc(Math.round((l - 4) / 2))
      let o = 0,
        c = 0
      for (let h = 4; h < l; h += 2)
        (o = ((s.buffer[h] & 127) | ((s.buffer[h + 1] & 127) << 7)) & 255),
          r.writeUInt8(o, c++)
      ;(s.firmware = {
        name: r.toString(),
        version: { major: s.buffer[2], minor: s.buffer[3] },
      }),
        s.emit("queryfirmware", s.firmware)
    },
    [It](s) {
      const l = Object.keys(s.MODES).map((E) => s.MODES[E])
      let r,
        o,
        c = 0
      function h(E) {
        return l.reduce((u, m) => (E & (1 << m) && u.push(m), u), [])
      }
      if (!s.pins.length)
        for (let E = 2, u = 0; E < s.buffer.length - 1; E++) {
          if (s.buffer[E] === 127) {
            s.pins.push({
              supportedModes: h(c),
              mode: void 0,
              value: 0,
              report: 1,
            }),
              (c = 0),
              (u = 0)
            continue
          }
          u === 0 &&
            ((r = s.buffer[E]),
            (o = (1 << s.buffer[E + 1]) - 1),
            (c |= 1 << r),
            r === s.MODES.ANALOG &&
              s.RESOLUTION.ADC === null &&
              (s.RESOLUTION.ADC = o),
            r === s.MODES.PWM &&
              s.RESOLUTION.PWM === null &&
              (s.RESOLUTION.PWM = o)),
            (u ^= 1)
        }
      s.emit("capability-query")
    },
    [Wt](s) {
      let l = s.buffer[2]
      ;(s.pins[l].mode = s.buffer[3]),
        (s.pins[l].state = s.buffer[4]),
        s.buffer.length > 6 && (s.pins[l].state |= s.buffer[5] << 7),
        s.buffer.length > 7 && (s.pins[l].state |= s.buffer[6] << 14),
        s.emit(`pin-state-${l}`)
    },
    [dt](s) {
      let l = 0,
        r
      for (let o = 2; o < s.buffer.length - 1; o++)
        (r = s.buffer[o]),
          (s.pins[l].analogChannel = r),
          r !== 127 && s.analogPins.push(l),
          l++
      s.emit("analog-mapping-query")
    },
    [Rt](s) {
      const l = [],
        r = (s.buffer[2] & 127) | ((s.buffer[3] & 127) << 7),
        o = (s.buffer[4] & 127) | ((s.buffer[5] & 127) << 7)
      for (let c = 6, h = s.buffer.length - 1; c < h; c += 2)
        l.push(s.buffer[c] | (s.buffer[c + 1] << 7))
      s.emit(`I2C-reply-${r}-${o}`, l)
    },
    [ee](s) {
      const l = s.buffer[2]
      !z[l] || z[l](s)
    },
    [Ft](s) {
      const l = s.buffer[3],
        r = s.buffer.slice(4, s.buffer.length - 1)
      s.emit(`1-wire-search-reply-${l}`, Oe.readDevices(r))
    },
    [Ot](s) {
      const l = s.buffer[3],
        r = s.buffer.slice(4, s.buffer.length - 1)
      s.emit(`1-wire-search-alarms-reply-${l}`, Oe.readDevices(r))
    },
    [Tt](s) {
      const l = s.buffer.slice(4, s.buffer.length - 1),
        r = Le.from7BitArray(l),
        o = (r[1] << 8) | r[0]
      s.emit(`1-wire-read-reply-${o}`, r.slice(2))
    },
    [ke](s) {
      s.emit(
        "string",
        K.Buffer.from(s.buffer.slice(2, -1)).toString().replace(/\0/g, "")
      )
    },
    [ae](s) {
      const l = (s.buffer[2] & 127) | ((s.buffer[3] & 127) << 7),
        r = [
          (s.buffer[4] & 127) | ((s.buffer[5] & 127) << 7),
          (s.buffer[6] & 127) | ((s.buffer[7] & 127) << 7),
          (s.buffer[8] & 127) | ((s.buffer[9] & 127) << 7),
          (s.buffer[10] & 127) | ((s.buffer[11] & 127) << 7),
        ],
        o = (r[0] << 24) + (r[1] << 16) + (r[2] << 8) + r[3]
      s.emit(`ping-read-${l}`, o)
    },
    [Ee](s) {
      const l = s.buffer[2]
      s.emit(`stepper-done-${l}`, !0)
    },
    [D](s) {
      const l = s.buffer[2],
        r = s.buffer[3],
        o = l === 6 || l === 10 ? be(s.buffer.slice(4, 9)) : null
      l === 6 && s.emit(`stepper-position-${r}`, o),
        l === 10 && s.emit(`stepper-done-${r}`, o),
        l === 36 && s.emit(`multi-stepper-done-${r}`)
    },
    [G](s) {
      const l = s.buffer[2] & _,
        r = s.buffer[2] & 15,
        o = []
      if (l === Vt) {
        for (let c = 3, h = s.buffer.length; c < h - 1; c += 2)
          o.push((s.buffer[c + 1] << 7) | s.buffer[c])
        s.emit(`serial-data-${r}`, o)
      }
    },
  },
  k = class extends gt {
    constructor(r, o, c) {
      super()
      A(this, "transport")
      A(this, "buffer", [])
      A(this, "isReady", !1)
      A(this, "settings")
      A(this, "_events", [])
      A(this, "MODES", {
        INPUT: 0,
        OUTPUT: 1,
        ANALOG: 2,
        PWM: 3,
        SERVO: 4,
        SHIFT: 5,
        I2C: 6,
        ONEWIRE: 7,
        STEPPER: 8,
        SERIAL: 10,
        PULLUP: 11,
        IGNORE: 127,
        PING_READ: 117,
        UNKOWN: 16,
      })
      A(this, "I2C_MODES", {
        WRITE: 0,
        READ: 1,
        CONTINUOUS_READ: 2,
        STOP_READING: 3,
      })
      A(this, "STEPPER", {
        TYPE: { DRIVER: 1, TWO_WIRE: 2, THREE_WIRE: 3, FOUR_WIRE: 4 },
        STEP_SIZE: { WHOLE: 0, HALF: 1 },
        RUN_STATE: { STOP: 0, ACCEL: 1, DECEL: 2, RUN: 3 },
        DIRECTION: { CCW: 0, CW: 1 },
      })
      A(this, "SERIAL_MODES", { CONTINUOUS_READ: 0, STOP_READING: 1 })
      A(this, "SERIAL_PORT_IDs", {
        HW_SERIAL0: 0,
        HW_SERIAL1: 1,
        HW_SERIAL2: 2,
        HW_SERIAL3: 3,
        SW_SERIAL0: 8,
        SW_SERIAL1: 9,
        SW_SERIAL2: 16,
        SW_SERIAL3: 17,
        DEFAULT: 8,
      })
      A(this, "SERIAL_PIN_TYPES", {
        RES_RX0: 0,
        RES_TX0: 1,
        RES_RX1: 2,
        RES_TX1: 3,
        RES_RX2: 4,
        RES_TX2: 5,
        RES_RX3: 6,
        RES_TX3: 7,
      })
      A(this, "RESOLUTION", { ADC: null, DAC: null, PWM: null })
      A(this, "HIGH", 1)
      A(this, "LOW", 0)
      A(this, "defaultPin", {
        value: 0,
        mode: this.MODES.INPUT,
        supportedModes: [this.MODES.INPUT, this.MODES.OUTPUT],
        report: 0,
        state: 0,
        analogChannel: 0,
      })
      A(this, "pins", new Array(128).fill(this.defaultPin))
      A(this, "ports", Array(16).fill(0))
      A(this, "analogPins", [])
      A(this, "version", { major: 0, minor: 0 })
      A(this, "firmware", {})
      A(this, "versionReceived", !1)
      A(this, "name", "Firmata")
      A(this, "pending", 0)
      A(this, "digitalPortQueue", 0)
      A(this, "reportVersionTimeoutId")
      A(this, "analogWrite", this.pwmWrite)
      A(this, "servoWrite", this.pwmWrite)
      ;(typeof o == "function" || typeof o == "undefined") &&
        ((c = o), (o = {}))
      const h = this,
        u = Object.assign(
          {},
          {
            reportVersionTimeout: 5e3,
            samplingInterval: 19,
            serialport: { baudRate: 57600, highWaterMark: 256 },
          },
          o
        )
      if (((this.settings = u), typeof r == "object")) this.transport = r
      else throw new Error("Missing Transport")
      this.transport.on("close", (I) => {
        if (I) {
          this.emit("disconnect")
          return
        }
        this.emit("close")
      }),
        this.transport.on("open", (I) => {
          this.emit("open", I), this.emit("connect", I)
        }),
        this.transport.on("error", (I) => {
          !this.isReady && typeof c == "function" ? c(I) : this.emit("error", I)
        }),
        this.transport.on("data", (I) => {
          for (let w = 0; w < I.length; w++) {
            let y = I[w]
            if (!(this.buffer.length === 0 && y === 0)) {
              this.buffer.push(y)
              let R = this.buffer[0],
                O = this.buffer[this.buffer.length - 1]
              if (R === _ && O === g) {
                let C = z[this.buffer[1]]
                C && this.versionReceived && C(this), (this.buffer.length = 0)
              } else if (R === _ && this.buffer.length > 0) {
                let C = I[w]
                C > 127 && ((this.buffer.length = 0), this.buffer.push(C))
              } else if (R !== _) {
                let C = R < _ ? R & _ : R
                C !== te && C !== he && C !== le && (this.buffer.length = 0)
              }
              if (this.buffer.length === 3 && R !== _) {
                let C = R < _ ? R & _ : R
                re[C]
                  ? ((this.versionReceived || R === te) &&
                      ((this.versionReceived = !0), re[C](this)),
                    (this.buffer.length = 0))
                  : (this.buffer.length = 0)
              }
            }
          }
        }),
        (this.reportVersionTimeoutId = setTimeout(() => {
          this.versionReceived === !1 &&
            (this.reportVersion(function () {}),
            this.queryFirmware(function () {}))
        }, u.reportVersionTimeout))
      function m() {
        ;(h.isReady = !0), h.emit("ready"), typeof c == "function" && c()
      }
      this.once("reportversion", () => {
        clearTimeout(this.reportVersionTimeoutId),
          (this.versionReceived = !0),
          this.once("queryfirmware", () => {
            if (
              (o.samplingInterval !== void 0 &&
                this.setSamplingInterval(o.samplingInterval),
              u.skipCapabilities)
            ) {
              if (
                ((this.analogPins = u.analogPins || this.analogPins),
                (this.pins = u.pins || this.pins),
                !this.pins.length)
              )
                for (var I = 0; I < (u.pinCount || Qt); I++) {
                  var w = [],
                    y = this.analogPins.indexOf(I)
                  y < 0 && (y = 127),
                    this.pins.push({ supportedModes: w, analogChannel: y })
                }
              ;(this.RESOLUTION.ADC = 1023), (this.RESOLUTION.PWM = 255), m()
            } else
              this.queryCapabilities(() => {
                this.queryAnalogMapping(m)
              })
          })
      })
    }
    reportVersion(r) {
      this.once("reportversion", r), S(this, [te])
    }
    queryFirmware(r) {
      this.once("queryfirmware", r), S(this, [_, We, g])
    }
    analogRead(r, o) {
      this.reportAnalogPin(r, 1), this.addListener(`analog-read-${r}`, o)
    }
    pwmWrite(r, o) {
      let c
      ;(this.pins[r].value = o),
        r > 15
          ? ((c = [_, At, r, o & 127, (o >> 7) & 127]),
            o > 16384 && (c[c.length] = (o >> 14) & 127),
            o > 2097152 && (c[c.length] = (o >> 21) & 127),
            o > 268435456 && (c[c.length] = (o >> 28) & 127),
            (c[c.length] = g))
          : (c = [he | r, o & 127, (o >> 7) & 127]),
        S(this, c)
    }
    servoConfig(r, o, c) {
      if (typeof r == "object" && r !== null) {
        let h = r
        ;(r = h.pin), (o = h.min), (c = h.max)
      }
      if (typeof r == "undefined")
        throw new Error("servoConfig: pin must be specified")
      if (typeof o == "undefined")
        throw new Error("servoConfig: min must be specified")
      if (typeof c == "undefined")
        throw new Error("servoConfig: max must be specified")
      ;(this.pins[r].mode = this.MODES.SERVO),
        S(this, [_, vt, r, o & 127, (o >> 7) & 127, c & 127, (c >> 7) & 127, g])
    }
    pinMode(r, o) {
      o === this.MODES.ANALOG
        ? (this.pins[this.analogPins[r]].mode = o)
        : ((this.pins[r].mode = o), S(this, [Mt, r, o]))
    }
    digitalWrite(r, o, c) {
      let h = this.updateDigitalPort(r, o)
      c ? (this.digitalPortQueue |= 1 << h) : this.writeDigitalPort(h)
    }
    updateDigitalPort(r, o) {
      const c = r >> 3,
        h = 1 << (r & 7)
      return (
        (this.pins[r].value = o),
        o ? (this.ports[c] |= h) : (this.ports[c] &= ~h),
        c
      )
    }
    flushDigitalPorts() {
      for (let r = 0; r < this.ports.length; r++)
        this.digitalPortQueue >> r && this.writeDigitalPort(r)
      this.digitalPortQueue = 0
    }
    writeDigitalPort(r) {
      S(this, [le | r, this.ports[r] & 127, (this.ports[r] >> 7) & 127])
    }
    digitalRead(r, o) {
      this.reportDigitalPin(r, 1), this.addListener(`digital-read-${r}`, o)
    }
    queryCapabilities(r) {
      this.once("capability-query", r), S(this, [_, yt, g])
    }
    queryAnalogMapping(r) {
      this.once("analog-mapping-query", r), S(this, [_, St, g])
    }
    queryPinState(r, o) {
      this.once(`pin-state-${r}`, o), S(this, [_, Lt, r, g])
    }
    sendString(r) {
      const o = K.Buffer.from(`${r}\0`, "utf8"),
        c = []
      c.push(_, ke)
      for (let h = 0, E = o.length; h < E; h++)
        c.push(o[h] & 127, (o[h] >> 7) & 127)
      c.push(g), S(this, c)
    }
    sendI2CConfig(r) {
      return this.i2cConfig(r)
    }
    i2cConfig(r) {
      let o = J.get(this),
        c
      return (
        o || ((o = {}), J.set(this, o)),
        typeof r == "number"
          ? (c = r)
          : typeof r == "object" &&
            r !== null &&
            ((c = Number(r.delay)),
            typeof r.address != "undefined" &&
              (o[r.address] || (o[r.address] = { stopTX: !0 })),
            typeof r.settings != "undefined" &&
              Object.assign(o[r.address], r.settings)),
        (o.delay = c = c || 0),
        V(this, [_, wt, c & 255, (c >> 8) & 255, g]),
        this
      )
    }
    sendI2CWriteRequest(r, o) {
      const c = []
      ;(o = o || []), c.push(_, v, r, this.I2C_MODES.WRITE << 3)
      for (let h = 0, E = o.length; h < E; h++)
        c.push(o[h] & 127, (o[h] >> 7) & 127)
      c.push(g), V(this, c)
    }
    i2cWrite(r, o, c) {
      const h = [_, v, r, this.I2C_MODES.WRITE << 3]
      if (arguments.length === 3 && !Array.isArray(o) && !Array.isArray(c))
        return this.i2cWriteReg(r, o, c)
      arguments.length === 2 &&
        (Array.isArray(o) ? ((c = o.slice()), (o = c.shift())) : (c = []))
      const E = K.Buffer.from([o].concat(c))
      for (var u = 0, m = E.length; u < m; u++)
        h.push(E[u] & 127, (E[u] >> 7) & 127)
      return h.push(g), V(this, h), this
    }
    i2cWriteReg(r, o, c) {
      return (
        V(this, [
          _,
          v,
          r,
          this.I2C_MODES.WRITE << 3,
          o & 127,
          (o >> 7) & 127,
          c & 127,
          (c >> 7) & 127,
          g,
        ]),
        this
      )
    }
    sendI2CReadRequest(r, o, c) {
      V(this, [_, v, r, this.I2C_MODES.READ << 3, o & 127, (o >> 7) & 127, g]),
        this.once(`I2C-reply-${r}-0`, c)
    }
    i2cRead(r, o, c, h) {
      arguments.length === 3 &&
        typeof o == "number" &&
        typeof c == "function" &&
        ((h = c), (c = o), (o = null))
      const E = [_, v, r, this.I2C_MODES.CONTINUOUS_READ << 3]
      let u = `I2C-reply-${r}-`
      return (
        o !== null ? E.push(o & 127, (o >> 7) & 127) : (o = 0),
        (u += o),
        E.push(c & 127, (c >> 7) & 127, g),
        this.on(u, h),
        V(this, E),
        this
      )
    }
    i2cStop(r) {
      r != null &&
        (typeof r == "number" && (r = { address: r }),
        S(this, [_, v, r.address, this.I2C_MODES.STOP_READING << 3, g]),
        Object.keys(this._events).forEach((o) => {
          o.startsWith(`I2C-reply-${r.address}`) && this.removeAllListeners(o)
        }))
    }
    i2cReadOnce(r, o, c, h) {
      arguments.length === 3 &&
        typeof o == "number" &&
        typeof c == "function" &&
        ((h = c), (c = o), (o = null))
      const E = [_, v, r, this.I2C_MODES.READ << 3]
      let u = `I2C-reply-${r}-`
      return (
        o !== null ? E.push(o & 127, (o >> 7) & 127) : (o = 0),
        (u += o),
        E.push(c & 127, (c >> 7) & 127, g),
        this.once(u, h),
        V(this, E),
        this
      )
    }
    sendOneWireConfig(r, o) {
      S(this, [_, ee, Ct, r, o ? 1 : 0, g])
    }
    sendOneWireSearch(r, o) {
      this[ie](Dt, `1-wire-search-reply-${r}`, r, o)
    }
    sendOneWireAlarmsSearch(r, o) {
      this[ie](Ut, `1-wire-search-alarms-reply-${r}`, r, o)
    }
    [ie](r, o, c, h) {
      S(this, [_, ee, r, c, g])
      const E = setTimeout(() => {
        h(
          new Error(
            "1-Wire device search timeout - are you running ConfigurableFirmata?"
          )
        )
      }, 5e3)
      this.once(o, (u) => {
        clearTimeout(E), h(null, u)
      })
    }
    sendOneWireRead(r, o, c, h) {
      const E = Math.floor(Math.random() * 255),
        u = setTimeout(() => {
          h(
            new Error(
              "1-Wire device read timeout - are you running ConfigurableFirmata?"
            )
          )
        }, 5e3)
      this[X](r, Ue, o, c, E, null, null, `1-wire-read-reply-${E}`, (m) => {
        clearTimeout(u), h(null, m)
      })
    }
    sendOneWireReset(r) {
      this[X](r, Bt)
    }
    sendOneWireWrite(r, o, c) {
      this[X](r, Fe, o, null, null, null, Array.isArray(c) ? c : [c])
    }
    sendOneWireDelay(r, o) {
      this[X](r, xt, null, null, null, o)
    }
    sendOneWireWriteAndRead(r, o, c, h, E) {
      const u = Math.floor(Math.random() * 255),
        m = setTimeout(() => {
          E(
            new Error(
              "1-Wire device read timeout - are you running ConfigurableFirmata?"
            )
          )
        }, 5e3)
      this[X](
        r,
        Fe | Ue,
        o,
        h,
        u,
        null,
        Array.isArray(c) ? c : [c],
        `1-wire-read-reply-${u}`,
        (I) => {
          clearTimeout(m), E(null, I)
        }
      )
    }
    [X](r, o, c, h, E, u, m, I, w) {
      const y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      ;(c || h || E || u || m) && (o = o | Nt),
        h && ((y[8] = h & 255), (y[9] = (h >> 8) & 255)),
        E && ((y[10] = E & 255), (y[11] = (E >> 8) & 255)),
        u &&
          ((y[12] = u & 255),
          (y[13] = (u >> 8) & 255),
          (y[14] = (u >> 16) & 255),
          (y[15] = (u >> 24) & 255)),
        m && y.push(...m)
      const R = [_, ee, o, r, ...Le.to7BitArray(y), g]
      S(this, R), I && w && this.once(I, w)
    }
    setSamplingInterval(r) {
      const o = r < 10 ? 10 : r > 65535 ? 65535 : r
      ;(this.settings.samplingInterval = o),
        S(this, [_, $t, o & 127, (o >> 7) & 127, g])
    }
    getSamplingInterval() {
      return this.settings.samplingInterval
    }
    reportAnalogPin(r, o) {
      ;(o === 0 || o === 1) &&
        ((this.pins[this.analogPins[r]].report = o), S(this, [kt | r, o]))
    }
    reportDigitalPin(r, o) {
      const c = r >> 3
      ;(o === 0 || o === 1) && ((this.pins[r].report = o), S(this, [bt | c, o]))
    }
    pingRead(r, o) {
      if (!this.pins[r.pin].supportedModes.includes(ae))
        throw new Error("Please upload PingFirmata to the board")
      const { pin: c, value: h, pulseOut: E = 0, timeout: u = 1e6 } = r
      S(this, [
        _,
        ae,
        c,
        h,
        ...k.encode([
          (E >> 24) & 255,
          (E >> 16) & 255,
          (E >> 8) & 255,
          E & 255,
        ]),
        ...k.encode([
          (u >> 24) & 255,
          (u >> 16) & 255,
          (u >> 8) & 255,
          u & 255,
        ]),
        g,
      ]),
        this.once(`ping-read-${c}`, o)
    }
    accelStepperConfig(r) {
      let {
        deviceNum: o,
        invertPins: c,
        motorPin1: h,
        motorPin2: E,
        motorPin3: u,
        motorPin4: m,
        enablePin: I,
        stepSize: w = this.STEPPER.STEP_SIZE.WHOLE,
        type: y = this.STEPPER.TYPE.FOUR_WIRE,
      } = r
      const R = [_, D, 0, o]
      let O = ((y & 7) << 4) | ((w & 7) << 1),
        C = 0
      typeof I != "undefined" && (O = O | 1),
        R.push(O),
        [
          "stepPin",
          "motorPin1",
          "directionPin",
          "motorPin2",
          "motorPin3",
          "motorPin4",
          "enablePin",
        ].forEach((b) => {
          typeof r[b] != "undefined" && R.push(r[b])
        }),
        Array.isArray(c) &&
          (c.includes(h) && (C |= 1),
          c.includes(E) && (C |= 2),
          c.includes(u) && (C |= 4),
          c.includes(m) && (C |= 8),
          c.includes(I) && (C |= 16)),
        R.push(C, g),
        S(this, R)
    }
    accelStepperZero(r) {
      S(this, [_, D, 1, r, g])
    }
    accelStepperStep(r, o, c) {
      S(this, [_, D, 2, r, ...ne(o), g]), c && this.once(`stepper-done-${r}`, c)
    }
    accelStepperTo(r, o, c) {
      S(this, [_, D, 3, r, ...ne(o), g]), c && this.once(`stepper-done-${r}`, c)
    }
    accelStepperEnable(r, o = !0) {
      S(this, [_, D, 4, r, o ? 1 : 0, g])
    }
    accelStepperStop(r) {
      S(this, [_, D, 5, r, g])
    }
    accelStepperReportPosition(r, o) {
      S(this, [_, D, 6, r, g]), o && this.once(`stepper-position-${r}`, o)
    }
    accelStepperAcceleration(r, o) {
      S(this, [_, D, 8, r, ..._e(o), g])
    }
    accelStepperSpeed(r, o) {
      S(this, [_, D, 9, r, ..._e(o), g])
    }
    multiStepperConfig(r) {
      S(this, [_, D, 32, r.groupNum, ...r.devices, g])
    }
    multiStepperTo(r, o, c) {
      if (r < 0 || r > 5)
        throw new RangeError(
          `Invalid "groupNum": ${r}. Expected "groupNum" between 0-5`
        )
      S(this, [_, D, 33, r, ...o.reduce((h, E) => h.concat(...ne(E)), []), g]),
        c && this.once(`multi-stepper-done-${r}`, c)
    }
    multiStepperStop(r) {
      if (r < 0 || r > 5)
        throw new RangeError(
          `Invalid "groupNum": ${r}. Expected "groupNum" between 0-5`
        )
      S(this, [_, D, 35, r, g])
    }
    stepperConfig(r, o, c, h, E, u, m) {
      S(this, [
        _,
        Ee,
        0,
        r,
        o,
        c & 127,
        (c >> 7) & 127,
        h,
        E,
        ...(o === this.STEPPER.TYPE.FOUR_WIRE ? [u, m] : []),
        g,
      ])
    }
    stepperStep(r, o, c, h, E, u, m) {
      typeof E == "function" && ((m = E), (E = 0), (u = 0)),
        S(this, [
          _,
          Ee,
          1,
          r,
          o,
          c & 127,
          (c >> 7) & 127,
          (c >> 14) & 127,
          h & 127,
          (h >> 7) & 127,
          ...(E > 0 || u > 0
            ? [E & 127, (E >> 7) & 127, u & 127, (u >> 7) & 127]
            : []),
          g,
        ]),
        m && this.once(`stepper-done-${r}`, m)
    }
    serialConfig(r) {
      let o, c, h, E
      if (
        (typeof r == "object" &&
          r !== null &&
          ((o = r.portId), (c = r.baud), (h = r.rxPin), (E = r.txPin)),
        typeof o == "undefined")
      )
        throw new Error(
          "portId must be specified, see SERIAL_PORT_IDs for options."
        )
      c = c || 57600
      const u = [_, G, Gt | o, c & 127, (c >> 7) & 127, (c >> 14) & 127]
      if (o > 7 && typeof h != "undefined" && typeof E != "undefined")
        u.push(h, E)
      else if (o > 7)
        throw new Error(
          "Both RX and TX pins must be defined when using Software Serial."
        )
      u.push(g), S(this, u)
    }
    serialWrite(r, o) {
      const c = [_, G, Yt | r]
      for (let h = 0, E = o.length; h < E; h++)
        c.push(o[h] & 127, (o[h] >> 7) & 127)
      c.push(g), o.length > 0 && S(this, c)
    }
    serialRead(r, o, c) {
      const h = [_, G, De | r, this.SERIAL_MODES.CONTINUOUS_READ]
      arguments.length === 2 && typeof o == "function"
        ? (c = o)
        : h.push(o & 127, (o >> 7) & 127),
        h.push(g),
        S(this, h),
        this.on(`serial-data-${r}`, c)
    }
    serialStop(r) {
      S(this, [_, G, De | r, this.SERIAL_MODES.STOP_READING, g]),
        this.removeAllListeners(`serial-data-${r}`)
    }
    serialClose(r) {
      S(this, [_, G, Xt | r, g])
    }
    serialFlush(r) {
      S(this, [_, G, Ht | r, g])
    }
    serialListen(r) {
      r < 8 || S(this, [_, G, jt | r, g])
    }
    sysexResponse(r, o) {
      if (k.SYSEX_RESPONSE[r])
        throw new Error(`${r} is not an available SYSEX_RESPONSE byte`)
      return (
        (k.SYSEX_RESPONSE[r] = (c) => o.call(c, c.buffer.slice(2, -1))), this
      )
    }
    clearSysexResponse(r) {
      k.SYSEX_RESPONSE[r] && delete k.SYSEX_RESPONSE[r]
    }
    sysexCommand(r) {
      if (!r || !r.length) throw new Error("Sysex Command cannot be empty")
      return S(this, [_, ...r.slice(), g]), this
    }
    reset() {
      S(this, [qt])
    }
    static encode(r) {
      const o = [],
        c = r.length
      for (let h = 0; h < c; h++) o.push(r[h] & 127, (r[h] >> 7) & 127)
      return o
    }
    static decode(r) {
      const o = []
      if (r.length % 2 !== 0)
        throw new Error(
          "Firmata.decode(data) called with odd number of data bytes"
        )
      for (; r.length; ) {
        const c = r.shift(),
          h = r.shift()
        o.push(c | (h << 7))
      }
      return o
    }
  }
let Firmata = k
export Firmata
A(M, "SYSEX_RESPONSE", z),
  A(M, "MIDI_RESPONSE", re),
  A(M, "Board", k),
  A(M, "test")
M.Board = M
M.SYSEX_RESPONSE = z
M.MIDI_RESPONSE = re
function S(s, l) {
  s.pending++, s.transport.write(l, () => s.pending--)
}
function V(s, l) {
  const r = J.get(s)
  if (!r)
    throw new Error(
      "I2C is not enabled for this board. To enable, call the i2cConfig() method."
    )
  if (l[1] === v) {
    const o = l[2]
    r[o] || (r[o] = { stopTX: !0 }),
      l[3] & Pt && (l[3] |= Number(!r[o].stopTX) << 6)
  }
  S(s, l)
}
function ne(s) {
  const l = s < 0
  s = Math.abs(s)
  const r = [
    s & 127,
    (s >> 7) & 127,
    (s >> 14) & 127,
    (s >> 21) & 127,
    (s >> 28) & 7,
  ]
  return l && (r[r.length - 1] |= 8), r
}
function be(s) {
  let l =
    (s[0] & 127) |
    ((s[1] & 127) << 7) |
    ((s[2] & 127) << 14) |
    ((s[3] & 127) << 21) |
    ((s[4] & 7) << 28)
  return s[4] >> 3 && (l *= -1), l
}
const Ne = Math.pow(2, 23)
function _e(s) {
  const l = s < 0 ? 1 : 0
  s = Math.abs(s)
  const r = Math.floor(Math.log10(s))
  let o = 0 + r
  for (s /= Math.pow(10, r); !Number.isInteger(s) && s < Ne; )
    (o -= 1), (s *= 10)
  for (; s > Ne; ) (o += 1), (s /= 10)
  return (
    (s = Math.trunc(s)),
    (o += 11),
    [
      s & 127,
      (s >> 7) & 127,
      (s >> 14) & 127,
      ((s >> 21) & 3) | ((o & 15) << 2) | ((l & 1) << 6),
    ]
  )
}
function Kt(s) {
  const l = ((s[3] >> 2) & 15) - 11,
    r = (s[3] >> 6) & 1
  let o = s[0] | (s[1] << 7) | (s[2] << 14) | ((s[3] & 3) << 21)
  return r && (o *= -1), o * Math.pow(10, l)
}
;({
  ALLUSERSPROFILE: "C:\\ProgramData",
  APPDATA: "C:\\Users\\ASUS\\AppData\\Roaming",
  CANoe_InstallDir: "C:\\Program Files\\Vector CANalyzer 8.5\\Exec64\\",
  ChocolateyInstall: "C:\\ProgramData\\chocolatey",
  ChocolateyLastPathUpdate: "132838556066730759",
  CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_26808_UKROFEREUTPYYVFU",
  COLORTERM: "truecolor",
  CommonProgramFiles: "C:\\Program Files\\Common Files",
  "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files",
  CommonProgramW6432: "C:\\Program Files\\Common Files",
  COMPUTERNAME: "DESKTOP-8D80I0B",
  ComSpec: "C:\\Windows\\system32\\cmd.exe",
  DAS_HOME: "C:\\Program Files (x86)\\DAS",
  DriverData: "C:\\Windows\\System32\\Drivers\\DriverData",
  ETAS_BOOST_1610_BIN:
    "C:\\Program Files (x86)\\Common Files\\ETAS\\3rdParty4.0\\",
  ETAS_BOOST_1770_BIN_X64:
    "C:\\Program Files\\Common Files\\ETAS\\3rdParty6.0\\",
  ETAS_XERCESC_312_BIN:
    "C:\\Program Files (x86)\\Common Files\\ETAS\\3rdParty4.0\\",
  ETAS_XERCESC_323_BIN_X64:
    "C:\\Program Files\\Common Files\\ETAS\\3rdParty6.0\\",
  FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer",
  FPS_BROWSER_USER_PROFILE_STRING: "Default",
  GIT_ASKPASS:
    "c:\\Users\\ASUS\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh",
  HOMEDRIVE: "C:",
  HOMEPATH: "\\Users\\ASUS",
  HSPDataDir: "C:\\ETASData\\HSP\\",
  INIT_CWD: "C:\\ys\\exp\\githubRepo\\sim",
  LANG: "ko_KR.UTF-8",
  LOCALAPPDATA: "C:\\Users\\ASUS\\AppData\\Local",
  LOGONSERVER: "\\\\DESKTOP-8D80I0B",
  NODE: "C:\\Program Files\\nodejs\\node.exe",
  NODE_ENV: "production",
  npm_config_argv:
    '{"remain":[],"cooked":["run","vite"],"original":["vite","build"]}',
  npm_config_bin_links: "true",
  npm_config_ignore_optional: "",
  npm_config_ignore_scripts: "",
  npm_config_init_license: "MIT",
  npm_config_init_version: "1.0.0",
  npm_config_python: "C:\\Python27\\",
  npm_config_registry: "https://registry.yarnpkg.com",
  npm_config_save_prefix: "^",
  npm_config_strict_ssl: "true",
  npm_config_user_agent: "yarn/1.22.18 npm/? node/v16.13.1 win32 x64",
  npm_config_version_commit_hooks: "true",
  npm_config_version_git_message: "v%s",
  npm_config_version_git_sign: "",
  npm_config_version_git_tag: "true",
  npm_config_version_tag_prefix: "v",
  npm_execpath:
    "C:\\Users\\ASUS\\AppData\\Roaming\\npm\\node_modules\\yarn\\bin\\yarn.js",
  npm_lifecycle_event: "vite",
  npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe",
  npm_package_dependencies_browser_serialport: "^2.1.0",
  npm_package_dependencies_events: "^3.3.0",
  npm_package_dependencies_mitt: "^3.0.0",
  npm_package_dependencies_serialport: "^10.4.0",
  npm_package_description:
    "Combination of Firmata, Avrgirl-arduino, RxJS, RxJS Ninja Svelte, Sveltestrap and TypeScript built with Vite.",
  npm_package_devDependencies_awty: "^0.1.0",
  npm_package_devDependencies_buffer: "^6.0.3",
  npm_package_devDependencies_es6_symbol: "^3.1.3",
  npm_package_devDependencies_graceful_fs: "^4.2.10",
  npm_package_devDependencies_intel_hex: "^0.1.2",
  npm_package_devDependencies_process: "^0.11.10",
  npm_package_devDependencies_rxjs: "^7.5.5",
  npm_package_devDependencies_serialport_binding_webserialapi: "^1.0.3",
  npm_package_devDependencies_stream: "^0.0.2",
  npm_package_devDependencies_svelte: "^3.44.0",
  npm_package_devDependencies_sveltestrap: "^5.9.0",
  npm_package_devDependencies_svelte_check: "^2.2.7",
  npm_package_devDependencies_svelte_preprocess: "^4.9.8",
  npm_package_devDependencies_svelte_sheets: "^1.0.0",
  npm_package_devDependencies_tslib: "^2.3.1",
  npm_package_devDependencies_tweakpane: "^3.1.0",
  npm_package_devDependencies_typescript: "^4.5.4",
  npm_package_devDependencies_util: "^0.12.4",
  npm_package_devDependencies_util_inherits: "^1.0.3",
  npm_package_devDependencies_vite: "^2.9.9",
  npm_package_devDependencies_vite_plugin_static_copy: "^0.6.1",
  npm_package_devDependencies__originjs_vite_plugin_commonjs: "^1.0.3",
  npm_package_devDependencies__rxjs_ninja_rxjs_utility: "^5.1.2",
  npm_package_devDependencies__sveltejs_vite_plugin_svelte: "^1.0.0-next.30",
  npm_package_devDependencies__tsconfig_svelte: "^2.0.1",
  npm_package_devDependencies__tweakpane_core: "^1.1.0",
  npm_package_devDependencies__types_w3c_web_serial: "^1.0.2",
  npm_package_license: "MIT",
  npm_package_name: "firmata.io",
  npm_package_private: "true",
  npm_package_readmeFilename: "README.md",
  npm_package_scripts_build: "vite build",
  npm_package_scripts_check: "svelte-check --tsconfig ./tsconfig.json",
  npm_package_scripts_dev: "vite",
  npm_package_scripts_preview: "vite preview",
  npm_package_scripts_start: "vite --open",
  npm_package_type: "module",
  npm_package_version: "0.0.0",
  NUMBER_OF_PROCESSORS: "16",
  OneDrive:
    "C:\\Users\\ASUS\\OneDrive - \uC8FC\uC2DD\uD68C\uC0AC \uD14C\uB108\uC9C0",
  OneDriveCommercial:
    "C:\\Users\\ASUS\\OneDrive - \uC8FC\uC2DD\uD68C\uC0AC \uD14C\uB108\uC9C0",
  OPENSSL_CONF: "C:\\Program Files (x86)\\GnuWin32\\share\\openssl.cnf",
  ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
  OS: "Windows_NT",
  Path: "C:\\Users\\ASUS\\AppData\\Local\\Temp\\yarn--1657702218371-0.8731653242980757;C:\\ys\\exp\\githubRepo\\sim\\node_modules\\.bin;C:\\Users\\ASUS\\AppData\\Local\\Yarn\\Data\\link\\node_modules\\.bin;C:\\Users\\ASUS\\AppData\\Local\\Yarn\\bin;C:\\Program Files\\libexec\\lib\\node_modules\\npm\\bin\\node-gyp-bin;C:\\Program Files\\lib\\node_modules\\npm\\bin\\node-gyp-bin;C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\node-gyp-bin;C:\\Program Files\\Common Files\\ETAS\\3rdParty6.0\\;C:\\Program Files (x86)\\Common Files\\ETAS\\3rdParty4.0\\;C:\\Program Files\\ImageMagick-7.1.0-Q16-HDRI;C:\\Python310\\Scripts\\;C:\\Python310\\;C:\\VMware\\VMware Player\\bin\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\AOMEI Backupper;C:\\Program Files (x86)\\WinMerge;C:\\Program Files\\nodejs\\;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\TortoiseSVN\\bin;C:\\Program Files (x86)\\Common Files\\ETAS\\ETASShared12\\CalculatedSignals;C:\\Program Files\\Git\\cmd;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn\\;C:\\Program Files\\PuTTY\\;C:\\Program Files\\TortoiseGit\\bin;C:\\Program Files (x86)\\GnuWin32\\bin;C:\\Users\\ASUS\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\ASUS\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\ASUS\\AppData\\Roaming\\npm;C:\\Users\\ASUS\\AppData\\Local\\GitHubDesktop\\bin;C:\\ys\\bin;",
  PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL",
  PROCESSOR_ARCHITECTURE: "AMD64",
  PROCESSOR_IDENTIFIER: "AMD64 Family 25 Model 80 Stepping 0, AuthenticAMD",
  PROCESSOR_LEVEL: "25",
  PROCESSOR_REVISION: "5000",
  ProgramData: "C:\\ProgramData",
  ProgramFiles: "C:\\Program Files",
  "ProgramFiles(x86)": "C:\\Program Files (x86)",
  ProgramW6432: "C:\\Program Files",
  PROMPT: "$P$G",
  PSModulePath:
    "C:\\Users\\ASUS\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules",
  PUBLIC: "C:\\Users\\Public",
  SESSIONNAME: "Console",
  SystemDrive: "C:",
  SystemRoot: "C:\\Windows",
  TEMP: "C:\\Users\\ASUS\\AppData\\Local\\Temp",
  TERM_PROGRAM: "vscode",
  TERM_PROGRAM_VERSION: "1.69.1",
  TMP: "C:\\Users\\ASUS\\AppData\\Local\\Temp",
  USERDOMAIN: "DESKTOP-8D80I0B",
  USERDOMAIN_ROAMINGPROFILE: "DESKTOP-8D80I0B",
  USERNAME: "ASUS",
  USERPROFILE: "C:\\Users\\ASUS",
  VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node",
  VSCODE_GIT_ASKPASS_MAIN:
    "c:\\Users\\ASUS\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js",
  VSCODE_GIT_ASKPASS_NODE:
    "C:\\Users\\ASUS\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe",
  VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-956988777a-sock",
  windir: "C:\\Windows",
  YARN_WRAP_OUTPUT: "false",
}.IS_TEST_MODE &&
  (M.test = {
    i2cPeripheralSettings(s) {
      return J.get(s)
    },
    get i2cActive() {
      return J
    },
    set transport(s) {},
    restoreTransport() {},
    encode32BitSignedInteger: ne,
    decode32BitSignedInteger: be,
    encodeCustomFloat: _e,
    decodeCustomFloat: Kt,
    writeToTransport: S,
    symbols: { SYM_sendOneWireRequest: X, SYM_sendOneWireSearch: ie },
  }))
